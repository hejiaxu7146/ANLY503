---
title: "Network"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(plyr)
library(networkD3)
library(igraph)
MyData <- read.csv(file="finalnetworkdata.csv", header=TRUE, sep=",")
edgeList <- MyData
# change the names of the columns
colnames(edgeList) <- c("SourceName", "TargetName", "Weight")
# Create a graph
  # Use simplify to ensure that there are no duplicated edges or self loops
gD <- igraph::simplify(igraph::graph.data.frame(edgeList, directed=FALSE))
# Create a node list object that will contain information about nodes
nodeList <- data.frame(ID = c(0:(igraph::vcount(gD) - 1)), nName = igraph::V(gD)$name)
# getNodeID is a function that takes a name and returns a row location -1
getNodeID <- function(x){
  which(x == igraph::V(gD)$name) - 1 # to ensure that IDs start at 0
}
# add this new info to the node list
nodeList <- cbind(nodeList, nodeDegree=igraph::degree(gD, v = igraph::V(gD), mode = "all"))
# add some new info to the edge list, then, too
edgeList <- plyr::ddply(edgeList, .variables = c("SourceName", "TargetName" , "Weight"), 
                        function (x) data.frame(SourceID = getNodeID(x$SourceName), 
                                                TargetID = getNodeID(x$TargetName)))
# Calculate betweenness for all nodes
#The betweenness value for each node n is normalized 
  #by dividing by the number of node pairs excluding n: (N-1)(N-2)/2, 
betAll <- igraph::betweenness(gD, v = igraph::V(gD), directed = FALSE) / (((igraph::vcount(gD) - 1) * (igraph::vcount(gD)-2)) / 2)
betAll.norm <- (betAll - min(betAll))/(max(betAll) - min(betAll))
# We are scaling the value by multiplying it by 100 for visualization 
  # purposes only (to create larger nodes)
nodeList <- cbind(nodeList, nodeBetweenness=100*betAll.norm) 
# similarity
dsAll <- igraph::similarity.dice(gD, vids = igraph::V(gD), mode = "all")
#Create  data frame that contains the Dice similarity between any two vertices
F1 <- function(x) {data.frame(diceSim = dsAll[x$SourceID +1, x$TargetID + 1])}
#Place a new column in edgeList with the Dice Sim
edgeList <- plyr::ddply(edgeList, .variables=c("SourceName", "TargetName", "Weight", "SourceID", "TargetID"),function(x) data.frame(F1(x)))

# # create a set of colors for each edge, based on their dice similarity values
F2 <- colorRampPalette(c("#FFFF00", "#FF0000"), bias = nrow(edgeList), space = "rgb", interpolate = "linear")
colCodes <- F2(length(unique(edgeList$diceSim)))
edges_col <- sapply(edgeList$diceSim, function(x) colCodes[which(sort(unique(edgeList$diceSim)) == x)])
# 
# rm(colCodes, F2)

# build the actual network
D3_network_LM <- networkD3::forceNetwork(Links = edgeList, Nodes = nodeList, Source = "SourceID",
                                         Target = "TargetID", Value = "Weight", NodeID = "nName", 
                                         Nodesize = "nodeBetweenness", Group = "nodeBetweenness", 
                                         height = 800, width = 800, fontSize = 15, 
                                         linkDistance = networkD3::JS("function(d) { return 10*d.value; }"),
                                         linkWidth = networkD3::JS("function(d) { return d.value/5; }"),
                                         opacity = 0.85, # opacity
                                         zoom = TRUE, 
                                         opacityNoHover = 0.6,  
                                         linkColour = edges_col)

networkD3::saveNetwork(D3_network_LM, "D3_network_exam.html", selfcontained = TRUE)
```

